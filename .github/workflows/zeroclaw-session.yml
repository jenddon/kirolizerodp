name: ZeroClaw Session

on:
  workflow_dispatch:
    inputs:
      session_id:
        description: 'Session identifier (auto-generated for chains)'
        required: false
        default: ''
      chain_count:
        description: 'Chain iteration counter'
        required: false
        default: '0'
      zeroclaw_cache_version:
        description: 'Bump to force zeroclaw rebuild (e.g. v1 -> v2)'
        required: false
        default: 'v1'
  repository_dispatch:
    types: [chain-zeroclaw]

env:
  CHAIN_TRIGGER_MINUTES: 345
  SAVE_INTERVAL_MINUTES: 60
  ZEROCLAW_PORT: 18789
  ANTIGRAVITY_TOKEN_URL: "https://oauth2.googleapis.com/token"

concurrency:
  group: zeroclaw-session
  cancel-in-progress: true

jobs:
  zeroclaw-session:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate session info
        id: session
        run: |
          SESSION_ID="${{ github.event.inputs.session_id }}"
          if [ -z "$SESSION_ID" ]; then
            SESSION_ID=$(uuidgen | cut -c1-8)
          fi

          CHAIN_COUNT="${{ github.event.inputs.chain_count }}"
          if [ -z "$CHAIN_COUNT" ]; then
            CHAIN_COUNT=0
          fi

          ZEROCLAW_CACHE_VERSION="${{ github.event.inputs.zeroclaw_cache_version }}"

          # Handle repository_dispatch payload
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            PAYLOAD_COUNT="${{ github.event.client_payload.chain_count }}"
            if [ -n "$PAYLOAD_COUNT" ]; then
              CHAIN_COUNT="$PAYLOAD_COUNT"
            fi
            PAYLOAD_CACHE="${{ github.event.client_payload.zeroclaw_cache_version }}"
            if [ -n "$PAYLOAD_CACHE" ]; then
              ZEROCLAW_CACHE_VERSION="$PAYLOAD_CACHE"
            fi
          fi

          if [ -z "$ZEROCLAW_CACHE_VERSION" ]; then
            ZEROCLAW_CACHE_VERSION="v1"
          fi

          JOB_START=$(date +%s)

          echo "SESSION_ID=$SESSION_ID" >> "$GITHUB_OUTPUT"
          echo "CHAIN_COUNT=$CHAIN_COUNT" >> "$GITHUB_OUTPUT"
          echo "ZEROCLAW_CACHE_VERSION=$ZEROCLAW_CACHE_VERSION" >> "$GITHUB_OUTPUT"
          echo "JOB_START=$JOB_START" >> "$GITHUB_OUTPUT"

          echo "Session: $SESSION_ID | Chain: $CHAIN_COUNT | Cache: $ZEROCLAW_CACHE_VERSION"

      # ========== RUST TOOLCHAIN ==========
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      # ========== CACHING ==========
      - name: Restore ZeroClaw binary cache
        id: cache-zeroclaw
        uses: actions/cache/restore@v4
        with:
          path: ~/.cargo/bin/zeroclaw
          key: zeroclaw-bin-${{ steps.session.outputs.ZEROCLAW_CACHE_VERSION }}-${{ runner.os }}

      # ========== ZEROCLAW BUILD ==========
      - name: Build and install ZeroClaw
        run: |
          # Check if cache restored a working zeroclaw binary
          CACHE_WORKING=false
          if [ "${{ steps.cache-zeroclaw.outputs.cache-hit }}" = "true" ]; then
            if command -v zeroclaw &>/dev/null; then
              VER=$(zeroclaw --version 2>&1) && CACHE_WORKING=true
              echo "ZeroClaw restored from cache: $VER"
            else
              echo "WARNING: Cache hit but zeroclaw binary not found"
            fi
          else
            echo "No binary cache hit (version: ${{ steps.session.outputs.ZEROCLAW_CACHE_VERSION }})"
          fi

          if [ "$CACHE_WORKING" = "false" ]; then
            echo "Building zeroclaw from source..."
            git clone --depth 1 https://github.com/zeroclaw-labs/zeroclaw.git /tmp/zeroclaw-src
            cd /tmp/zeroclaw-src
            # Use release-fast profile for GitHub Actions runners (16GB+ RAM)
            cargo install --path . --force --locked --profile release-fast 2>/dev/null \
              || cargo install --path . --force --locked
            cd /
            rm -rf /tmp/zeroclaw-src
            echo "ZeroClaw installed: $(zeroclaw --version)"
          fi

      - name: Install browser dependencies
        run: |
          # ZeroClaw's agent_browser backend may use Playwright or native WebDriver.
          # Install Playwright + Chromium as a safe default (ZeroClaw auto-detects).
          npx playwright install --with-deps chromium 2>/dev/null || {
            echo "WARNING: Playwright install failed (browser tools may not work)"
            echo "ZeroClaw will fall back to non-browser tools"
          }
          echo "Browser dependencies installed"

      # ========== OAUTH TOKEN REFRESH ==========
      - name: Refresh OAuth tokens
        id: oauth
        env:
          ZEROCLAW_AUTH_PROFILES: ${{ secrets.ZEROCLAW_AUTH_PROFILES }}
          ANTIGRAVITY_CLIENT_ID: ${{ secrets.ANTIGRAVITY_CLIENT_ID }}
          ANTIGRAVITY_CLIENT_SECRET: ${{ secrets.ANTIGRAVITY_CLIENT_SECRET }}
        run: |
          ZEROCLAW_DIR="$HOME/.zeroclaw"
          GEMINI_DIR="$HOME/.gemini"
          mkdir -p "$ZEROCLAW_DIR"
          mkdir -p "$GEMINI_DIR"

          if [ -z "$ZEROCLAW_AUTH_PROFILES" ]; then
            echo "ERROR: No ZEROCLAW_AUTH_PROFILES secret found"
            exit 1
          fi

          # Write auth profiles to disk
          echo "$ZEROCLAW_AUTH_PROFILES" > "$ZEROCLAW_DIR/auth-profiles.json"

          # Refresh all google-antigravity OAuth tokens
          # The auth-profiles.json contains refresh tokens we can use with the antigravity client ID/secret
          echo "Refreshing OAuth tokens..."

          BEST_PROFILE=""
          BEST_ACCESS=""
          BEST_EXPIRES=0
          PROFILES_UPDATED=false

          # Extract profile keys and iterate
          PROFILE_KEYS=$(jq -r '.profiles | keys[]' "$ZEROCLAW_DIR/auth-profiles.json")

          for PROFILE_KEY in $PROFILE_KEYS; do
            PROVIDER=$(jq -r ".profiles[\"$PROFILE_KEY\"].provider" "$ZEROCLAW_DIR/auth-profiles.json")
            REFRESH_TOKEN=$(jq -r ".profiles[\"$PROFILE_KEY\"].refresh" "$ZEROCLAW_DIR/auth-profiles.json")
            EMAIL=$(jq -r ".profiles[\"$PROFILE_KEY\"].email" "$ZEROCLAW_DIR/auth-profiles.json")

            if [ "$PROVIDER" != "google-antigravity" ] || [ -z "$REFRESH_TOKEN" ] || [ "$REFRESH_TOKEN" = "null" ]; then
              echo "  Skipping $PROFILE_KEY (provider=$PROVIDER)"
              continue
            fi

            echo "  Refreshing token for: $EMAIL"

            # Refresh the access token using the antigravity client credentials
            RESPONSE=$(curl -sf -X POST "$ANTIGRAVITY_TOKEN_URL" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "client_id=$ANTIGRAVITY_CLIENT_ID" \
              -d "client_secret=$ANTIGRAVITY_CLIENT_SECRET" \
              -d "refresh_token=$REFRESH_TOKEN" \
              -d "grant_type=refresh_token" 2>&1) || {
              echo "    FAILED to refresh token for $EMAIL"
              continue
            }

            NEW_ACCESS=$(echo "$RESPONSE" | jq -r '.access_token // empty')
            EXPIRES_IN=$(echo "$RESPONSE" | jq -r '.expires_in // 3600')

            if [ -z "$NEW_ACCESS" ]; then
              echo "    No access_token in response for $EMAIL"
              echo "    Response: $RESPONSE"
              continue
            fi

            # Calculate expiry as RFC 3339 datetime (ZeroClaw's gemini.rs uses chrono::DateTime::parse_from_rfc3339)
            EXPIRES_AT_EPOCH=$(($(date +%s) + EXPIRES_IN - 300))  # now + expires_in - 5min safety margin
            EXPIRES_RFC3339=$(date -u -d "@$EXPIRES_AT_EPOCH" '+%Y-%m-%dT%H:%M:%S+00:00')

            # Update the auth-profiles.json with new access token and expiry epoch
            jq ".profiles[\"$PROFILE_KEY\"].access = \"$NEW_ACCESS\" | .profiles[\"$PROFILE_KEY\"].expires = $EXPIRES_AT_EPOCH" \
              "$ZEROCLAW_DIR/auth-profiles.json" > "$ZEROCLAW_DIR/auth-profiles.tmp" && \
              mv "$ZEROCLAW_DIR/auth-profiles.tmp" "$ZEROCLAW_DIR/auth-profiles.json"

            PROFILES_UPDATED=true
            echo "    OK: token refreshed for $EMAIL (expires at $EXPIRES_RFC3339)"

            # Track the best (most recently refreshed) profile for ~/.gemini/oauth_creds.json
            if [ "$EXPIRES_AT_EPOCH" -gt "$BEST_EXPIRES" ]; then
              BEST_PROFILE="$PROFILE_KEY"
              BEST_ACCESS="$NEW_ACCESS"
              BEST_EXPIRES="$EXPIRES_AT_EPOCH"
              BEST_EXPIRES_RFC3339="$EXPIRES_RFC3339"
            fi
          done

          if [ "$PROFILES_UPDATED" = "false" ]; then
            echo "WARNING: No OAuth tokens were successfully refreshed!"
            echo "ZeroClaw will fall back to NVIDIA_API_KEY if available"
          fi

          # Write the best token to ~/.gemini/oauth_creds.json for ZeroClaw's built-in gemini provider
          if [ -n "$BEST_ACCESS" ]; then
            BEST_EMAIL=$(jq -r ".profiles[\"$BEST_PROFILE\"].email" "$ZEROCLAW_DIR/auth-profiles.json")
            BEST_REFRESH=$(jq -r ".profiles[\"$BEST_PROFILE\"].refresh" "$ZEROCLAW_DIR/auth-profiles.json")

            # ZeroClaw's gemini.rs reads: access_token (string) + expiry (RFC 3339 string)
            # It uses chrono::DateTime::parse_from_rfc3339 to check expiry
            jq -n \
              --arg access_token "$BEST_ACCESS" \
              --arg expiry "$BEST_EXPIRES_RFC3339" \
              '{access_token: $access_token, expiry: $expiry}' \
              > "$GEMINI_DIR/oauth_creds.json"

            echo "Wrote best OAuth token to ~/.gemini/oauth_creds.json ($BEST_EMAIL, expires: $BEST_EXPIRES_RFC3339)"
            echo "BEST_PROFILE=$BEST_PROFILE" >> "$GITHUB_OUTPUT"
            echo "BEST_EMAIL=$BEST_EMAIL" >> "$GITHUB_OUTPUT"
          fi

          echo "OAuth refresh complete"

      # ========== ZEROCLAW CONFIG ==========
      - name: Configure ZeroClaw
        env:
          ZEROCLAW_CONFIG: ${{ secrets.ZEROCLAW_CONFIG }}
          NVIDIA_API_KEY: ${{ secrets.NVIDIA_API_KEY }}
          NVIDIA_API_KEY_2: ${{ secrets.NVIDIA_API_KEY_2 }}
          NVIDIA_API_KEY_3: ${{ secrets.NVIDIA_API_KEY_3 }}
          NVIDIA_API_KEY_4: ${{ secrets.NVIDIA_API_KEY_4 }}
          NVIDIA_API_KEY_5: ${{ secrets.NVIDIA_API_KEY_5 }}
          NVIDIA_API_KEY_6: ${{ secrets.NVIDIA_API_KEY_6 }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        run: |
          ZEROCLAW_DIR="$HOME/.zeroclaw"
          mkdir -p "$ZEROCLAW_DIR"

          # Inject config.toml from secret
          if [ -n "$ZEROCLAW_CONFIG" ]; then
            echo "$ZEROCLAW_CONFIG" > "$ZEROCLAW_DIR/config.toml"
            echo "Injected config.toml from ZEROCLAW_CONFIG secret"
          else
            # Fallback: use the config.toml from the repo
            if [ -f "config.toml" ]; then
              cp config.toml "$ZEROCLAW_DIR/config.toml"
              echo "Copied config.toml from repository"
            else
              echo "ERROR: No ZEROCLAW_CONFIG secret and no config.toml in repo"
              exit 1
            fi
          fi

          # Replace ${TELEGRAM_BOT_TOKEN} placeholder in config.toml
          if [ -n "$TELEGRAM_BOT_TOKEN" ]; then
            sed -i "s|\${TELEGRAM_BOT_TOKEN}|$TELEGRAM_BOT_TOKEN|g" "$ZEROCLAW_DIR/config.toml"
            echo "Injected Telegram bot token into config"
          else
            echo "WARNING: No TELEGRAM_BOT_TOKEN secret found"
          fi

          # Export all NVIDIA API keys for rotation pool
          echo "NVIDIA_API_KEY=$NVIDIA_API_KEY" >> "$GITHUB_ENV"
          echo "NVIDIA_API_KEY_2=$NVIDIA_API_KEY_2" >> "$GITHUB_ENV"
          echo "NVIDIA_API_KEY_3=$NVIDIA_API_KEY_3" >> "$GITHUB_ENV"
          echo "NVIDIA_API_KEY_4=$NVIDIA_API_KEY_4" >> "$GITHUB_ENV"
          echo "NVIDIA_API_KEY_5=$NVIDIA_API_KEY_5" >> "$GITHUB_ENV"
          echo "NVIDIA_API_KEY_6=$NVIDIA_API_KEY_6" >> "$GITHUB_ENV"
          echo "TELEGRAM_BOT_TOKEN=$TELEGRAM_BOT_TOKEN" >> "$GITHUB_ENV"

          echo "ZeroClaw configured"

      # ========== WORKSPACE RESTORE ==========
      - name: Find previous workspace artifact
        id: find-artifact
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          REPO="${{ github.repository }}"
          CURRENT_RUN_ID="${{ github.run_id }}"

          # Brief wait for previous session's artifact upload
          MAX_WAIT=15
          WAITED=0
          while [ "$WAITED" -lt "$MAX_WAIT" ]; do
            OTHER_RUNS=$(gh run list --repo "$REPO" --workflow "zeroclaw-session.yml" --status in_progress --json databaseId -q "[.[] | select(.databaseId != $CURRENT_RUN_ID)] | length")
            if [ "$OTHER_RUNS" -gt 0 ]; then
              echo "Previous session still running, waiting..."
              sleep 30
              WAITED=$((WAITED + 1))
            else
              break
            fi
          done

          # Find the latest artifact
          ARTIFACT_INFO=$(gh api "repos/$REPO/actions/artifacts" --jq '[.artifacts[] | select(.name == "zeroclaw-workspace" and .expired == false)] | first | "\(.id) \(.workflow_run.id)"' 2>/dev/null || echo "")

          if [ -n "$ARTIFACT_INFO" ] && [ "$ARTIFACT_INFO" != "null null" ]; then
            RUN_ID=$(echo "$ARTIFACT_INFO" | awk '{print $2}')
            echo "Found workspace artifact from run: $RUN_ID"
            echo "RUN_ID=$RUN_ID" >> "$GITHUB_OUTPUT"
            echo "FOUND=true" >> "$GITHUB_OUTPUT"
          else
            echo "No previous workspace artifact found"
            echo "FOUND=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Restore workspace from artifact
        if: steps.find-artifact.outputs.FOUND == 'true'
        uses: actions/download-artifact@v4
        with:
          name: zeroclaw-workspace
          path: ~/.zeroclaw/workspace
          github-token: ${{ secrets.GH_PAT }}
          run-id: ${{ steps.find-artifact.outputs.RUN_ID }}
        continue-on-error: true

      - name: Fix ZeroClaw directory permissions
        run: |
          chmod -R u+rwX "$HOME/.zeroclaw"
          chmod -R u+rwX "$HOME/.gemini" 2>/dev/null || true
          echo "Permissions fixed for ~/.zeroclaw and ~/.gemini"

      # ========== CLOUDFLARE TUNNEL ==========
      - name: Start Cloudflare Tunnel
        id: tunnel
        run: |
          # Install cloudflared
          curl -fsSL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -o cloudflared.deb
          sudo dpkg -i cloudflared.deb

          # Start tunnel for ZeroClaw gateway
          cloudflared tunnel --url http://localhost:${{ env.ZEROCLAW_PORT }} --no-autoupdate > /tmp/cloudflared.log 2>&1 &
          TUNNEL_PID=$!
          echo "TUNNEL_PID=$TUNNEL_PID" >> "$GITHUB_OUTPUT"

          # Wait for tunnel URL
          echo "Waiting for Cloudflare Tunnel URL..."
          for i in $(seq 1 30); do
            TUNNEL_URL=$(grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com' /tmp/cloudflared.log | head -1)
            if [ -n "$TUNNEL_URL" ]; then
              break
            fi
            sleep 2
          done

          if [ -z "$TUNNEL_URL" ]; then
            echo "Failed to get Cloudflare Tunnel URL"
            cat /tmp/cloudflared.log
            exit 1
          fi

          echo "TUNNEL_URL=$TUNNEL_URL" >> "$GITHUB_OUTPUT"
          echo "ZeroClaw gateway tunnel: $TUNNEL_URL"

      # ========== START ZEROCLAW ==========
      - name: Start ZeroClaw daemon
        run: |
          # Do NOT set ZEROCLAW_WORKSPACE — ZeroClaw derives its config/workspace
          # paths from $HOME. Setting it causes a doubled path:
          #   $HOME/.zeroclaw/.zeroclaw/config.toml (wrong)
          # Without it, ZeroClaw finds: $HOME/.zeroclaw/config.toml (correct)

          # Start ZeroClaw daemon in background (includes gateway + channels)
          nohup zeroclaw daemon --port ${{ env.ZEROCLAW_PORT }} > /tmp/zeroclaw.log 2>&1 &
          ZEROCLAW_PID=$!
          echo "$ZEROCLAW_PID" > /tmp/zeroclaw.pid

          # Wait and verify it started
          sleep 10
          if kill -0 "$ZEROCLAW_PID" 2>/dev/null; then
            echo "ZeroClaw daemon started (PID: $ZEROCLAW_PID)"
            echo "--- startup log ---"
            cat /tmp/zeroclaw.log
            echo "--- end startup log ---"
          else
            echo "ERROR: ZeroClaw daemon failed to start"
            cat /tmp/zeroclaw.log
            exit 1
          fi

      - name: Display Connection Info
        run: |
          TUNNEL_URL="${{ steps.tunnel.outputs.TUNNEL_URL }}"
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"
          CHAIN_COUNT="${{ steps.session.outputs.CHAIN_COUNT }}"
          BEST_EMAIL="${{ steps.oauth.outputs.BEST_EMAIL }}"

          echo ""
          echo "=============================================="
          echo "       ZEROCLAW SESSION READY"
          echo "=============================================="
          echo ""
          echo "Session ID:    $SESSION_ID"
          echo "Chain Count:   $CHAIN_COUNT"
          echo ""
          echo "ZeroClaw Gateway:"
          echo "  URL:       $TUNNEL_URL"
          echo "  Local:     http://localhost:${{ env.ZEROCLAW_PORT }}"
          echo ""
          echo "OAuth Profile: $BEST_EMAIL"
          echo ""
          echo "Available Models (switch via Telegram):"
          echo "  /model moonshotai/kimi-k2.5"
          echo "  /model nvidia/nemotron-3-nano-30b-a3b"
          echo "  /model MiniMaxAI/MiniMax-M1-80k"
          echo "  /model qwen/qwen3.5-397b-a17b"
          echo "  /model z-ai/glm5"
          echo "  /model stepfun-ai/step-3.5-flash"
          echo ""
          echo "Config:      ~/.zeroclaw/config.toml"
          echo "Workspace:   ~/.zeroclaw/workspace"
          echo "Gemini Auth: ~/.gemini/oauth_creds.json"
          echo "Log:         /tmp/zeroclaw.log"
          echo ""
          echo "Cache version: ${{ steps.session.outputs.ZEROCLAW_CACHE_VERSION }}"
          echo "Session will auto-chain at ~${{ env.CHAIN_TRIGGER_MINUTES }} minutes"
          echo "=============================================="

      # ========== KEEPALIVE ==========
      - name: Keep session alive
        id: keepalive
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          ANTIGRAVITY_CLIENT_ID: ${{ secrets.ANTIGRAVITY_CLIENT_ID }}
          ANTIGRAVITY_CLIENT_SECRET: ${{ secrets.ANTIGRAVITY_CLIENT_SECRET }}
        run: |
          JOB_START=${{ steps.session.outputs.JOB_START }}
          CHAIN_MINUTES=${{ env.CHAIN_TRIGGER_MINUTES }}
          HARD_LIMIT_MINUTES=350
          SAVE_INTERVAL=${{ env.SAVE_INTERVAL_MINUTES }}
          REPO="${{ github.repository }}"
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"
          CHAIN_COUNT=${{ steps.session.outputs.CHAIN_COUNT }}
          ZEROCLAW_CACHE_VERSION="${{ steps.session.outputs.ZEROCLAW_CACHE_VERSION }}"
          ZEROCLAW_DIR="$HOME/.zeroclaw"
          GEMINI_DIR="$HOME/.gemini"

          CHAIN_TIME=$((JOB_START + CHAIN_MINUTES * 60))
          HARD_LIMIT=$((JOB_START + HARD_LIMIT_MINUTES * 60))
          LAST_SAVE=$(date +%s)
          LAST_TOKEN_REFRESH=$(date +%s)
          TOKEN_REFRESH_INTERVAL=2700  # Refresh OAuth tokens every 45 minutes
          CHAIN_TRIGGERED=false
          FAIL_COUNT=0
          LOOP_COUNT=0

          # ── NVIDIA API key rotation pool ──
          # Build array of all available keys (skip empty ones)
          NVIDIA_KEYS=()
          for K in "$NVIDIA_API_KEY" "$NVIDIA_API_KEY_2" "$NVIDIA_API_KEY_3" "$NVIDIA_API_KEY_4" "$NVIDIA_API_KEY_5" "$NVIDIA_API_KEY_6"; do
            if [ -n "$K" ]; then
              NVIDIA_KEYS+=("$K")
            fi
          done
          NVIDIA_KEY_COUNT=${#NVIDIA_KEYS[@]}

          if [ "$NVIDIA_KEY_COUNT" -eq 0 ]; then
            echo "ERROR: No NVIDIA API keys available!"
            exit 1
          fi

          # Pick initial key based on chain count (round-robin across sessions)
          CURRENT_KEY_INDEX=$((CHAIN_COUNT % NVIDIA_KEY_COUNT))
          export NVIDIA_API_KEY="${NVIDIA_KEYS[$CURRENT_KEY_INDEX]}"
          RATE_LIMIT_LOG_POS=0

          echo "  NVIDIA key pool: $NVIDIA_KEY_COUNT keys"
          echo "  Initial key index: $CURRENT_KEY_INDEX (chain $CHAIN_COUNT % $NVIDIA_KEY_COUNT)"

          NOW=$(date +%s)
          SETUP_ELAPSED=$(( (NOW - JOB_START) / 60 ))
          REMAINING=$(( (CHAIN_TIME - NOW) / 60 ))

          echo "Keep alive started"
          echo "  Job started:      $(date -d @$JOB_START '+%H:%M:%S')"
          echo "  Setup took:       ${SETUP_ELAPSED} min"
          echo "  Chain trigger at: $(date -d @$CHAIN_TIME '+%H:%M:%S') (${CHAIN_MINUTES} min from job start)"
          echo "  Hard limit at:    $(date -d @$HARD_LIMIT '+%H:%M:%S') (${HARD_LIMIT_MINUTES} min from job start)"
          echo "  Remaining:        ${REMAINING} min"
          echo "  Save interval:    every ${SAVE_INTERVAL} min"
          echo "  Token refresh:    every $((TOKEN_REFRESH_INTERVAL / 60)) min"

          # Helper: rotate NVIDIA API key and restart daemon
          rotate_nvidia_key() {
            local REASON="${1:-unknown}"
            local OLD_INDEX=$CURRENT_KEY_INDEX
            CURRENT_KEY_INDEX=$(( (CURRENT_KEY_INDEX + 1) % NVIDIA_KEY_COUNT ))
            export NVIDIA_API_KEY="${NVIDIA_KEYS[$CURRENT_KEY_INDEX]}"

            echo "  [KEY-ROTATE] Rotating NVIDIA key: index $OLD_INDEX -> $CURRENT_KEY_INDEX ($REASON)"

            # Kill current daemon
            if [ -f /tmp/zeroclaw.pid ]; then
              ZEROCLAW_PID=$(cat /tmp/zeroclaw.pid)
              kill "$ZEROCLAW_PID" 2>/dev/null
              sleep 3
              kill -9 "$ZEROCLAW_PID" 2>/dev/null
            fi

            # Restart with new key
            nohup zeroclaw daemon --port ${{ env.ZEROCLAW_PORT }} >> /tmp/zeroclaw.log 2>&1 &
            NEW_PID=$!
            echo "$NEW_PID" > /tmp/zeroclaw.pid
            sleep 10
            if kill -0 "$NEW_PID" 2>/dev/null; then
              echo "  [KEY-ROTATE] Daemon restarted with new key (PID: $NEW_PID)"
              FAIL_COUNT=0
            else
              echo "  [KEY-ROTATE] WARNING: Daemon failed to start with new key"
              tail -20 /tmp/zeroclaw.log 2>/dev/null || true
            fi
          }

          # Helper: refresh OAuth tokens
          refresh_tokens() {
            echo "  [OAUTH] Refreshing OAuth tokens..."
            PROFILE_KEYS=$(jq -r '.profiles | keys[]' "$ZEROCLAW_DIR/auth-profiles.json" 2>/dev/null || echo "")
            BEST_ACCESS=""
            BEST_EXPIRES=0
            BEST_KEY=""

            for PROFILE_KEY in $PROFILE_KEYS; do
              PROVIDER=$(jq -r ".profiles[\"$PROFILE_KEY\"].provider" "$ZEROCLAW_DIR/auth-profiles.json")
              REFRESH_TOKEN=$(jq -r ".profiles[\"$PROFILE_KEY\"].refresh" "$ZEROCLAW_DIR/auth-profiles.json")

              if [ "$PROVIDER" != "google-antigravity" ] || [ -z "$REFRESH_TOKEN" ] || [ "$REFRESH_TOKEN" = "null" ]; then
                continue
              fi

              RESPONSE=$(curl -sf -X POST "$ANTIGRAVITY_TOKEN_URL" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -d "client_id=$ANTIGRAVITY_CLIENT_ID" \
                -d "client_secret=$ANTIGRAVITY_CLIENT_SECRET" \
                -d "refresh_token=$REFRESH_TOKEN" \
                -d "grant_type=refresh_token" 2>&1) || continue

              NEW_ACCESS=$(echo "$RESPONSE" | jq -r '.access_token // empty')
              EXPIRES_IN=$(echo "$RESPONSE" | jq -r '.expires_in // 3600')

              if [ -z "$NEW_ACCESS" ]; then
                continue
              fi

              EXPIRES_AT_EPOCH=$(($(date +%s) + EXPIRES_IN - 300))
              EXPIRES_RFC3339=$(date -u -d "@$EXPIRES_AT_EPOCH" '+%Y-%m-%dT%H:%M:%S+00:00')

              jq ".profiles[\"$PROFILE_KEY\"].access = \"$NEW_ACCESS\" | .profiles[\"$PROFILE_KEY\"].expires = $EXPIRES_AT_EPOCH" \
                "$ZEROCLAW_DIR/auth-profiles.json" > "$ZEROCLAW_DIR/auth-profiles.tmp" && \
                mv "$ZEROCLAW_DIR/auth-profiles.tmp" "$ZEROCLAW_DIR/auth-profiles.json"

              if [ "$EXPIRES_AT_EPOCH" -gt "$BEST_EXPIRES" ]; then
                BEST_KEY="$PROFILE_KEY"
                BEST_ACCESS="$NEW_ACCESS"
                BEST_EXPIRES="$EXPIRES_AT_EPOCH"
                BEST_EXPIRES_RFC3339="$EXPIRES_RFC3339"
              fi
            done

            # Update ~/.gemini/oauth_creds.json with best token
            if [ -n "$BEST_ACCESS" ]; then
              jq -n \
                --arg access_token "$BEST_ACCESS" \
                --arg expiry "$BEST_EXPIRES_RFC3339" \
                '{access_token: $access_token, expiry: $expiry}' \
                > "$GEMINI_DIR/oauth_creds.json"
              echo "  [OAUTH] Tokens refreshed at $(date '+%H:%M:%S')"
            else
              echo "  [OAUTH] WARNING: No tokens refreshed"
            fi
          }

          # Helper: save secrets
          save_secrets() {
            CONFIG_FILE="$ZEROCLAW_DIR/config.toml"
            AUTH_FILE="$ZEROCLAW_DIR/auth-profiles.json"
            if [ -f "$CONFIG_FILE" ]; then
              gh secret set ZEROCLAW_CONFIG --repo "$REPO" < "$CONFIG_FILE" 2>/dev/null || true
            fi
            if [ -f "$AUTH_FILE" ]; then
              gh secret set ZEROCLAW_AUTH_PROFILES --repo "$REPO" < "$AUTH_FILE" 2>/dev/null || true
            fi
            echo "  [SAVE] Secrets saved at $(date '+%H:%M:%S')"
          }

          # Helper: trigger chain
          trigger_chain() {
            NEXT_CHAIN=$((CHAIN_COUNT + 1))
            echo "  [CHAIN] Triggering next session (chain: $NEXT_CHAIN, cache: $ZEROCLAW_CACHE_VERSION)..."

            BODY=$(jq -n \
              --arg event_type "chain-zeroclaw" \
              --arg session_id "$SESSION_ID" \
              --argjson chain_count "$NEXT_CHAIN" \
              --arg cache_version "$ZEROCLAW_CACHE_VERSION" \
              '{event_type: $event_type, client_payload: {session_id: $session_id, chain_count: $chain_count, zeroclaw_cache_version: $cache_version}}')

            for i in 1 2 3; do
              echo "$BODY" | gh api "repos/$REPO/dispatches" --method POST --input - && {
                echo "  [CHAIN] Next session triggered on attempt $i"
                return 0
              }
              echo "  [CHAIN] WARNING: attempt $i failed"
              [ "$i" -lt 3 ] && sleep $((i * 10))
            done
            echo "  [CHAIN] ERROR: All 3 attempts failed!"
            return 1
          }

          # Main keepalive loop
          while [ "$(date +%s)" -lt "$HARD_LIMIT" ]; do
            LOOP_COUNT=$((LOOP_COUNT + 1))
            NOW=$(date +%s)
            ELAPSED=$(( (NOW - JOB_START) / 60 ))

            if [ "$CHAIN_TRIGGERED" = "false" ]; then
              LEFT=$(( (CHAIN_TIME - NOW) / 60 ))
              echo "Session alive at $(date '+%H:%M:%S') | ${ELAPSED}min elapsed | ${LEFT}min until chain"
            else
              LEFT=$(( (HARD_LIMIT - NOW) / 60 ))
              echo "Session alive at $(date '+%H:%M:%S') | ${ELAPSED}min elapsed | ${LEFT}min until hard limit (chained)"
            fi

            # Tail ZeroClaw log (last 30 lines of new output since last check)
            if [ -f /tmp/zeroclaw.log ]; then
              NEW_LINES=$(wc -l < /tmp/zeroclaw.log)
              LAST_LINES=${LAST_LOG_LINES:-0}
              if [ "$NEW_LINES" -gt "$LAST_LINES" ]; then
                DIFF=$((NEW_LINES - LAST_LINES))
                echo "  --- zeroclaw log (${DIFF} new lines) ---"
                tail -n "$DIFF" /tmp/zeroclaw.log | tail -30
                echo "  --- end log ---"

                # Detect rate limit errors in new log lines (429, rate limit, quota exceeded)
                RATE_HITS=$(tail -n "$DIFF" /tmp/zeroclaw.log | grep -ciE '429|rate.?limit|too many requests|quota.?exceeded|resource.?exhausted' || true)
                if [ "$RATE_HITS" -gt 0 ]; then
                  echo "  [RATE-LIMIT] Detected $RATE_HITS rate limit indicator(s) in recent log!"
                  rotate_nvidia_key "rate-limit-detected"
                fi
              fi
              LAST_LOG_LINES=$NEW_LINES
            fi

            # Check if ZeroClaw is running, restart if needed (with key rotation)
            if [ -f /tmp/zeroclaw.pid ]; then
              ZEROCLAW_PID=$(cat /tmp/zeroclaw.pid)
              if ! kill -0 "$ZEROCLAW_PID" 2>/dev/null; then
                FAIL_COUNT=$((FAIL_COUNT + 1))
                if [ "$FAIL_COUNT" -le 5 ]; then
                  echo "  ZeroClaw not running (attempt $FAIL_COUNT/5), rotating key and restarting..."
                  rotate_nvidia_key "crash-restart-$FAIL_COUNT"
                elif [ "$FAIL_COUNT" -eq 6 ]; then
                  echo "  ZeroClaw failed 5 consecutive restarts (all keys tried) - giving up automatic restarts."
                  echo "  Check log: /tmp/zeroclaw.log"
                fi
              else
                if [ "$FAIL_COUNT" -gt 0 ]; then
                  echo "  ZeroClaw confirmed running (reset fail counter from $FAIL_COUNT)"
                fi
                FAIL_COUNT=0
              fi
            fi

            # Check if cloudflared tunnel is still alive
            if ! pgrep -x cloudflared > /dev/null 2>&1; then
              echo "  WARNING: Cloudflare Tunnel process died, restarting..."
              cloudflared tunnel --url http://localhost:${{ env.ZEROCLAW_PORT }} --no-autoupdate > /tmp/cloudflared.log 2>&1 &
              sleep 5
              NEW_URL=$(grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com' /tmp/cloudflared.log | head -1)
              if [ -n "$NEW_URL" ]; then
                echo "  Tunnel restarted: $NEW_URL"
              else
                echo "  WARNING: Tunnel restart may have failed"
              fi
            fi

            # Periodic OAuth token refresh (every 45 min)
            NOW=$(date +%s)
            SINCE_TOKEN_REFRESH=$((NOW - LAST_TOKEN_REFRESH))
            if [ "$SINCE_TOKEN_REFRESH" -ge "$TOKEN_REFRESH_INTERVAL" ]; then
              refresh_tokens
              LAST_TOKEN_REFRESH=$(date +%s)
            fi

            # Periodic secret save
            NOW=$(date +%s)
            SINCE_SAVE=$(( (NOW - LAST_SAVE) / 60 ))
            if [ "$SINCE_SAVE" -ge "$SAVE_INTERVAL" ]; then
              save_secrets
              LAST_SAVE=$(date +%s)
            fi

            # Chain trigger
            if [ "$CHAIN_TRIGGERED" = "false" ] && [ "$(date +%s)" -ge "$CHAIN_TIME" ]; then
              echo ""
              echo "=========================================="
              echo "  CHAIN TIME - saving and triggering"
              echo "=========================================="
              refresh_tokens
              save_secrets
              if trigger_chain; then
                CHAIN_TRIGGERED=true
                echo "CHAIN_DONE=true" >> "$GITHUB_OUTPUT"
                echo "Chain triggered successfully - continuing until hard limit"
              else
                echo "WARNING: Chain trigger failed - will retry via fallback step"
              fi
              echo "=========================================="
              echo ""
            fi

            sleep 60
          done

          # Final save
          echo "Hard limit reached - final secret save"
          refresh_tokens
          save_secrets
          if [ "$CHAIN_TRIGGERED" = "false" ]; then
            echo "CHAIN_DONE=false" >> "$GITHUB_OUTPUT"
          fi

      # ========== CLEANUP & CHAIN (always runs) ==========
      - name: Save secrets (fallback)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          REPO="${{ github.repository }}"
          ZEROCLAW_DIR="$HOME/.zeroclaw"

          echo "Fallback secret save (in case keepalive was interrupted)..."
          CONFIG_FILE="$ZEROCLAW_DIR/config.toml"
          AUTH_FILE="$ZEROCLAW_DIR/auth-profiles.json"
          if [ -f "$CONFIG_FILE" ]; then
            gh secret set ZEROCLAW_CONFIG --repo "$REPO" < "$CONFIG_FILE" 2>/dev/null || true
          fi
          if [ -f "$AUTH_FILE" ]; then
            gh secret set ZEROCLAW_AUTH_PROFILES --repo "$REPO" < "$AUTH_FILE" 2>/dev/null || true
          fi
          echo "Secrets saved"
        continue-on-error: true

      - name: Clean workspace before upload
        if: always()
        run: |
          WORKSPACE="$HOME/.zeroclaw/workspace"

          if [ ! -d "$WORKSPACE" ]; then
            echo "No workspace to clean"
            exit 0
          fi

          echo "Cleaning transient/large files from workspace before upload..."

          # Remove known transient directories
          find "$WORKSPACE" -type d \( -name "node_modules" -o -name "__pycache__" -o -name ".venv" -o -name "venv" -o -name ".cache" -o -name "cache" -o -name "tmp" -o -name "temp" -o -name "downloads" \) -exec rm -rf {} + 2>/dev/null || true

          # Remove large/binary files
          find "$WORKSPACE" -type f \( -name "*.mp4" -o -name "*.mkv" -o -name "*.avi" -o -name "*.mov" -o -name "*.webm" -o -name "*.mp3" -o -name "*.wav" -o -name "*.flac" -o -name "*.zip" -o -name "*.tar" -o -name "*.gz" -o -name "*.7z" -o -name "*.rar" -o -name "*.iso" -o -name "*.img" -o -name "*.exe" -o -name "*.msi" -o -name "*.bin" -o -name "*.dat" -o -name "*.psd" -o -name "*.raw" \) -delete 2>/dev/null || true

          # Remove files larger than 50MB
          find "$WORKSPACE" -type f -size +50M -delete 2>/dev/null || true

          # Remove empty directories
          find "$WORKSPACE" -type d -empty -delete 2>/dev/null || true

          # Summary
          FILE_COUNT=$(find "$WORKSPACE" -type f 2>/dev/null | wc -l)
          SIZE=$(du -sh "$WORKSPACE" 2>/dev/null | cut -f1)
          echo "Workspace ready for upload: $FILE_COUNT files, $SIZE"

      - name: Upload workspace artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zeroclaw-workspace
          path: ~/.zeroclaw/workspace
          retention-days: 90
          if-no-files-found: ignore
          overwrite: true

      - name: Trigger next session (fallback)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Skip if keepalive already triggered the chain
          CHAIN_DONE="${{ steps.keepalive.outputs.CHAIN_DONE }}"
          if [ "$CHAIN_DONE" = "true" ]; then
            echo "Chain already triggered by keepalive loop - skipping fallback"
            exit 0
          fi

          echo "Fallback chain trigger (keepalive did not complete chain)..."

          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"
          NEXT_CHAIN=$(( ${{ steps.session.outputs.CHAIN_COUNT }} + 1 ))
          ZEROCLAW_CACHE_VERSION="${{ steps.session.outputs.ZEROCLAW_CACHE_VERSION }}"
          REPO="${{ github.repository }}"

          # If workflow was cancelled, toggle version to force zeroclaw rebuild
          KEEPALIVE_OUTCOME="${{ steps.keepalive.outcome }}"
          if [ "$KEEPALIVE_OUTCOME" = "cancelled" ]; then
            if [ "$ZEROCLAW_CACHE_VERSION" = "v1" ]; then
              NEW_VERSION="v2"
            else
              NEW_VERSION="v1"
            fi
            echo "=========================================="
            echo "CANCEL DETECTED - REBUILDING ZEROCLAW"
            echo "  Previous cache version: $ZEROCLAW_CACHE_VERSION"
            echo "  New cache version:      $NEW_VERSION"
            echo "=========================================="
            ZEROCLAW_CACHE_VERSION="$NEW_VERSION"
          fi

          echo "Triggering next session (chain count: $NEXT_CHAIN, zeroclaw cache: $ZEROCLAW_CACHE_VERSION)..."

          BODY=$(jq -n \
            --arg event_type "chain-zeroclaw" \
            --arg session_id "$SESSION_ID" \
            --argjson chain_count "$NEXT_CHAIN" \
            --arg cache_version "$ZEROCLAW_CACHE_VERSION" \
            '{event_type: $event_type, client_payload: {session_id: $session_id, chain_count: $chain_count, zeroclaw_cache_version: $cache_version}}')

          for i in 1 2 3; do
            echo "$BODY" | gh api "repos/$REPO/dispatches" --method POST --input - && {
              echo "Next session triggered on attempt $i"
              exit 0
            }
            echo "WARNING: attempt $i failed"
            [ "$i" -lt 3 ] && sleep $((i * 15))
          done
          echo "ERROR: All 3 attempts to trigger next session failed!"

      # ========== CACHE SAVE ==========
      - name: Save ZeroClaw binary cache
        if: ${{ always() && steps.cache-zeroclaw.outputs.cache-hit != 'true' }}
        uses: actions/cache/save@v4
        with:
          path: ~/.cargo/bin/zeroclaw
          key: zeroclaw-bin-${{ steps.session.outputs.ZEROCLAW_CACHE_VERSION }}-${{ runner.os }}
        continue-on-error: true
